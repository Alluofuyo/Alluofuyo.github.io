<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>网络地理信息系统实验三的一些小尝试</title>
    <link href="/20210527/%E7%BD%91%E7%BB%9C%E5%9C%B0%E7%90%86%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C%E4%B8%89%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B0%8F%E5%B0%9D%E8%AF%95/"/>
    <url>/20210527/%E7%BD%91%E7%BB%9C%E5%9C%B0%E7%90%86%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C%E4%B8%89%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B0%8F%E5%B0%9D%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<h3 id="for循环的练习"><a href="#for循环的练习" class="headerlink" title="for循环的练习"></a>for循环的练习</h3><p>在原例的基础上增加了正序、倒序的功能，点击按钮实现正序、倒序排序<br>代码如下：</p><div class="code-wrapper"><pre class="line-numbers language-html" data-language="html"><code class="language-html">&lt;html&gt;&lt;head&gt;  &lt;title&gt;循环语句练习&lt;&#x2F;title&gt;  &lt;script&gt;    var emp &#x3D; new Array(3);    emp[0] &#x3D; &quot;Ryan Dias&quot;;    emp[1] &#x3D; &quot;Graham Browne&quot;;    emp[2] &#x3D; &quot;David Greene&quot;;    emp.sort();    document.write(&quot;排序结果是: &lt;button&gt;正序&lt;&#x2F;button&gt;&lt;HR&gt;&quot;);    document.write(&quot;&lt;div id&#x3D;&#39;container&#39;&gt;&lt;div&gt;&quot;);    let container &#x3D; document.getElementById(&quot;container&quot;);    let btn &#x3D; document.getElementsByTagName(&quot;button&quot;)[0];    &#x2F;&#x2F;打印排序结果    const printResult &#x3D; () &#x3D;&gt; &#123;      for (var i &#x3D; 0; i &lt; emp.length; i++) &#123;        container.innerHTML +&#x3D; emp[i] + &quot;&lt;br&gt;&quot;;      &#125;      var x &#x3D; emp.join();      container.innerHTML +&#x3D; &quot;&lt;br&gt;&quot; + x;    &#125;;    printResult();    document.getElementsByTagName(&quot;button&quot;)[0].addEventListener(&quot;click&quot;, (e) &#x3D;&gt; &#123;      if (btn.textContent &#x3D;&#x3D;&#x3D; &quot;正序&quot;) &#123;        emp.sort((a, b) &#x3D;&gt; b.localeCompare(a));        container.innerHTML &#x3D; &quot;&quot;;        printResult();        btn.textContent &#x3D; &quot;倒序&quot;;      &#125; else &#123;        emp.sort((a, b) &#x3D;&gt; a.localeCompare(b));        container.innerHTML &#x3D; &quot;&quot;;        printResult();        btn.textContent &#x3D; &quot;正序&quot;;      &#125;    &#125;)  &lt;&#x2F;script&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre></div><hr><p>实现的效果如下</p><iframe allowtransparency="yes" frameborder="0" width="100%" height="210px" src="../../test/test_01.html" style="background-color: aliceblue;color: #333;padding: 20px;border-radius: 10px;box-shadow: 0 0 10px 2px turquoise;"></iframe><h3 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h3><p>另外一个引起我深思的是本次实验中关于对象创建的三种形式，一个是通过生产模式来新建对象，一个是构造函数来新建对象，另一个是prototype来构建对象，这三种方式的代码如下（我做了修改）：</p><div class="code-wrapper"><pre class="line-numbers language-html" data-language="html"><code class="language-html">&lt;html&gt;&lt;head&gt;  &lt;meta charset&#x3D;&quot;utf-8&quot;&gt;&lt;&#x2F;head&gt;&lt;body&gt;  &lt;div&gt;    &lt;button id&#x3D;&quot;create_car&quot;&gt;通过工厂模式生产小汽车&lt;&#x2F;button&gt;    &lt;div&gt;name: &lt;span id&#x3D;&quot;factory_name&quot;&gt;&lt;&#x2F;span&gt;&lt;&#x2F;div&gt;    &lt;div&gt;color: &lt;span id&#x3D;&quot;factory_color&quot;&gt;&lt;&#x2F;span&gt;&lt;&#x2F;div&gt;    &lt;div&gt;wheel: &lt;span id&#x3D;&quot;factory_wheel&quot;&gt;&lt;&#x2F;span&gt;&lt;&#x2F;div&gt;    &lt;script&gt;      function createCar(name, color, wheel) &#123;        let car &#x3D; new Object();        car.name &#x3D; name;        car.color &#x3D; color;        car.wheel &#x3D; wheel;        car.show &#x3D; () &#x3D;&gt; &#123;          alert(car.name);        &#125;        return car;      &#125;      document.getElementById(&quot;create_car&quot;).onclick &#x3D; () &#x3D;&gt; &#123;        let factory_car &#x3D; createCar(&quot;BMW&quot;, &quot;black&quot;, &quot;4&quot;);        document.getElementById(&quot;factory_name&quot;).textContent &#x3D; factory_car.name;        document.getElementById(&quot;factory_color&quot;).textContent &#x3D; factory_car.color;        document.getElementById(&quot;factory_wheel&quot;).textContent &#x3D; factory_car.wheel;        factory_car.show();      &#125;;    &lt;&#x2F;script&gt;  &lt;&#x2F;div&gt;  &lt;div&gt;    &lt;button id&#x3D;&quot;construct_car&quot;&gt;通过构造函数生产小汽车&lt;&#x2F;button&gt;    &lt;div&gt;name: &lt;span id&#x3D;&quot;construct_name&quot;&gt;&lt;&#x2F;span&gt;&lt;&#x2F;div&gt;    &lt;div&gt;color: &lt;span id&#x3D;&quot;construct_color&quot;&gt;&lt;&#x2F;span&gt;&lt;&#x2F;div&gt;    &lt;div&gt;wheel: &lt;span id&#x3D;&quot;construct_wheel&quot;&gt;&lt;&#x2F;span&gt;&lt;&#x2F;div&gt;    &lt;script&gt;      function Car(name, color, wheel) &#123;        this.name &#x3D; name;        this.color &#x3D; color;        this.wheel &#x3D; wheel;        this.show &#x3D; () &#x3D;&gt; &#123;          alert(this.name);        &#125;      &#125;      document.getElementById(&quot;construct_car&quot;).onclick &#x3D; () &#x3D;&gt; &#123;        let construct_car &#x3D; new Car(&quot;Benz&quot;, &quot;silver&quot;, &quot;4&quot;);        document.getElementById(&quot;construct_name&quot;).textContent &#x3D; construct_car.name;        document.getElementById(&quot;construct_color&quot;).textContent &#x3D; construct_car.color;        document.getElementById(&quot;construct_wheel&quot;).textContent &#x3D; construct_car.wheel;        construct_car.show();      &#125;;    &lt;&#x2F;script&gt;  &lt;&#x2F;div&gt;  &lt;div&gt;    &lt;button id&#x3D;&quot;prototype_car&quot;&gt;通过原型生产小汽车&lt;&#x2F;button&gt;    &lt;div&gt;name: &lt;span id&#x3D;&quot;prototype_name&quot;&gt;&lt;&#x2F;span&gt;&lt;&#x2F;div&gt;    &lt;div&gt;color: &lt;span id&#x3D;&quot;prototype_color&quot;&gt;&lt;&#x2F;span&gt;&lt;&#x2F;div&gt;    &lt;div&gt;wheel: &lt;span id&#x3D;&quot;prototype_wheel&quot;&gt;&lt;&#x2F;span&gt;&lt;&#x2F;div&gt;    &lt;script&gt;      function PCar(name, color, wheel) &#123;        this.name &#x3D; name;        PCar.prototype.color &#x3D; color;        this.wheel &#x3D; wheel;      &#125;      PCar.prototype.show &#x3D; () &#x3D;&gt; &#123;        alert(this.name);      &#125;;      document.getElementById(&quot;prototype_car&quot;).onclick &#x3D; () &#x3D;&gt; &#123;        let prototype_car &#x3D; new PCar(&quot;Audi&quot;, &quot;white&quot;, &quot;4&quot;);        document.getElementById(&quot;prototype_name&quot;).textContent &#x3D; prototype_car.name;        document.getElementById(&quot;prototype_color&quot;).textContent &#x3D; prototype_car.color;        document.getElementById(&quot;prototype_wheel&quot;).textContent &#x3D; prototype_car.wheel;        prototype_car.show();      &#125;;    &lt;&#x2F;script&gt;  &lt;&#x2F;div&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</code></pre></div><p>实现效果如下</p><iframe allowtransparency="yes" frameborder="0" width="100%" height="420px" src="../../test/test_02.html" style="background-color: aliceblue;color: #333;padding: 20px;border-radius: 10px;box-shadow: 0 0 10px 2px turquoise;"></iframe><p>其中，我对 new 到底做了什么产生了兴趣，首先我是想到了一个问题，构造函数和普通函数到底有什么区别？</p><h3 id="更进一步的深思"><a href="#更进一步的深思" class="headerlink" title="更进一步的深思"></a>更进一步的深思</h3><p>我知道普通函数，是通过return来将函数作用域内的值传递到函数外，工厂模式正是这样来返回一个对象实例，而构造函数，是在函数体内使用this来定义对象的结构，在函数外通过 new 来调用，从而返回一个新的对象实例，那么疑问来了，在JavaScript中，除了基本数据类型，万物皆对象，构造函数也是对象，普通函数也是对象，普通函数可以通过return返回新的对象实例，那构造函数为什么不能返回一个新的实例呢，因此我做了以下尝试：</p><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F;工厂模式返回对象function createCar(name)&#123;    var obj&#x3D;new Object();    obj.name&#x3D;name;    return obj;&#125;&#x2F;&#x2F;构造函数返回对象function Car(name)&#123;    this.name&#x3D;name;    return this;&#125;console.log(createCar(&quot;test01&quot;));console.log(Car(&quot;test02&quot;));</code></pre></div><p>控制台返回的结果如下:</p><p><img src="/20210527/%E7%BD%91%E7%BB%9C%E5%9C%B0%E7%90%86%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C%E4%B8%89%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B0%8F%E5%B0%9D%E8%AF%95/image-20210527041934854-1622060380359.png" alt="image-20210527041934854"></p><p>结果是在我意料之中，构造函数返回的是window对象，很显然，当把构造函数当作普通函数return时，this的指向为调用该函数的对象，在这里也就是window对象，因此，我们直接调用构造函数，显然是不对的。</p><p>我马上就想到了三个函数，call，bind 和 apply ， 这三个函数都可以改变 this 的指针，但是这需要一个指向的对象，也就是说，我们需要一个新建对象来使 this 指针指向它：</p><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">function Car(name)&#123;    this.name&#x3D;name;    return this;&#125;var obj&#x3D;new Object();console.log(Car.call(obj,&quot;test&quot;))</code></pre></div><p>控制台输出如下</p><p><img src="/20210527/%E7%BD%91%E7%BB%9C%E5%9C%B0%E7%90%86%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C%E4%B8%89%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B0%8F%E5%B0%9D%E8%AF%95/image-20210527042959226-1622061000417.png" alt="image-20210527042959226"></p><p>果然，这样确实返回了一个新的对象，但是我们依然使用了 new 来新建了一个空对象，那我们能不能不新建对象，让 obj 的值为undefined 呢？修改如下：</p><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var obj; &#x2F;&#x2F;声明而不赋值,此时的obj为undefined</code></pre></div><p>再次运行，结果与第一次一样 this 指向了 window 对象：</p><p><img src="/20210527/%E7%BD%91%E7%BB%9C%E5%9C%B0%E7%90%86%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C%E4%B8%89%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B0%8F%E5%B0%9D%E8%AF%95/image-20210527043359380-1622061241646.png" alt="image-20210527043359380"></p><p>也就是说，在这里，call 传入一个undefined 的值，this 会认为该值无效而指向函数的调用者，既然是这样，那我们继续向上溯根，也就是new 一个Object做了什么，继续以同样的思维，将Object 分解为两个步骤，为了跳出这个死循环，我尝试了以下代码，结果十分神奇：</p><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var obj;console.log(Object.call(obj))</code></pre></div><p>控制台输出如下：</p><p><img src="/20210527/%E7%BD%91%E7%BB%9C%E5%9C%B0%E7%90%86%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E5%AE%9E%E9%AA%8C%E4%B8%89%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B0%8F%E5%B0%9D%E8%AF%95/image-20210527044021815.png" alt="image-20210527044021815"></p><p>！！！竟然返回了一个新对象，也就是说，在Object构造函数用undefined做this指针，结果可以返回一个新的对象，这个地方有点转迷糊了，Object是window的一个函数对象，调用Object的构造函数时，它本身的this就是指向window的，这时传进去一个undefined 进去，构造函数认为这个值无效，仍然是传的window进去，所以最终效果是和new Object（）相同，返回了一个新的对象。</p><p>所以 new 到底是做了什么呢？</p><p>卡住了，不妨就去查查资料，通过查阅资料，了解到，new主要做了四样事情：</p><p>​    // new Base();</p><ol><li><p>创建一个空对象<br><code>var obj=&#123;&#125;</code></p></li><li><p>设置空对象的<code>__proto__</code>为Base 的prototype<br><code>obj.__proto__=Base.prototype</code></p></li><li><p>将<code>obj</code>设置为Base 的上下文<br><code>var result=Base.call(obj)</code></p></li><li><p>如果返回的是基本数据类型，则忽略返回值，如果是对象，则覆盖掉原始的构造实例，return null 除外</p><div class="code-wrapper"><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">if(typeof ret &#x3D;&#x3D; &#39;object&#39;)&#123;      return ret;&#125; else &#123;    return obj;&#125;</code></pre></div></li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>基本来说通过自己思考问题，是完全可以得到这个结果，但是我对空对象的创建仍然存疑，那么空对象是如何创建的呢，是和其他语言一样通过内存的分配从而在堆上新建一个实例吗？这些问题也可能是自己的能力有限，也许以后理解更加深刻了，一切就迎刃而解了。</p>]]></content>
    
    
    
    <tags>
      
      <tag>study</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
